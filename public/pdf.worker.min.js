/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2024 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 890:
/***/ ((module) => {

"use strict";


const EXPORT_NAME = "pdfjs-dist/build/pdf.worker";
const EXPORT_VERSION = "5.3.93";
module.exports = {
  EXPORT_NAME,
  EXPORT_VERSION
};

/***/ }),

/***/ 649:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _regenerator = _interopRequireDefault(__webpack_require__(936));
var _typeof = __webpack_require__(46);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkerMessageHandler = exports.WorkerTask = exports.WorkerTransport = void 0;
var _util = __webpack_require__(80);
var _primitives = __webpack_require__(240);
var _pdf_manager = __webpack_require__(375);
var _is_node = __webpack_require__(345);
var _message_handler = __webpack_require__(817);
var _base_stream = __webpack_require__(34);
var _worker_stream = __webpack_require__(277);
var _image = __webpack_require__(627);
var _murmurhash = __webpack_require__(608);
var _metadata_parser = __webpack_require__(82);
var _core_utils = __webpack_require__(397);
var _min_max_heap = __webpack_require__(54);
var _arithmetic_decoder = __webpack_require__(836);
var _bidi = __webpack_require__(996);
var _ccitt = __webpack_require__(68);
var _cff_parser = __webpack_require__(29);
var _cidmaps = __webpack_require__(763);
var _colorspace = __webpack_require__(71);
var _crypto = __webpack_require__(878);
var _encodings = __webpack_require__(70);
var _evaluator = __webpack_require__(184);
var _flate = __webpack_require__(377);
var _fonts = __webpack_require__(170);
var _function = __webpack_require__(103);
var _glyphlist = __webpack_require__(306);
var _image_utils = __webpack_require__(665);
var _jbig2 = __webpack_require__(810);
var _jpeg = __webpack_require__(848);
var _jpx = __webpack_require__(640);
var _lzw = __webpack_require__(486);
var _metrics = __webpack_require__(899);
var _multistream = __webpack_require__(51);
var _network = __webpack_require__(395);
var _network_utils = __webpack_require__(497);
var _parser = __webpack_require__(15);
var _pattern = __webpack_require__(192);
var _predictor = __webpack_require__(694);
var _run_length = __webpack_require__(407);
var _standard_fonts = __webpack_require__(58);
var _stream = __webpack_require__(246);
var _tiling_pattern = __webpack_require__(980);
var _type1_parser = __webpack_require__(181);
var _unicode = __webpack_require__(167);
var _writer = __webpack_require__(548);
var _xfa_html_utils = __webpack_require__(185);
var _xfa_object = __webpack_require__(30);
var _xfa_parser = __webpack_require__(269);
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var WorkerTask = function () {
  function WorkerTask(name) {
    _classCallCheck(this, WorkerTask);
    this._name = name;
    this._transport = null;
    this._capability = (0, _util.createPromiseCapability)();
    this._isCancelled = false;
    this._isFinished = false;
  }
  _createClass(WorkerTask, [{
    key: "name",
    get: function get() {
      return this._name;
    }
  }, {
    key: "finished",
    get: function get() {
      return this._capability.promise;
    }
  }, {
    key: "isCancelled",
    get: function get() {
      return this._isCancelled;
    }
  }, {
    key: "isFinished",
    get: function get() {
      return this._isFinished;
    }
  }, {
    key: "cancel",
    value: function cancel() {
      this._isCancelled = true;
      if (this._transport) {
        this._transport.cancel();
      }
    }
  }, {
    key: "finish",
    value: function finish() {
      var _this = this;
      if (this._isFinished) {
        return;
      }
      this._isFinished = true;
      Promise.resolve().then(function () {
        _this._capability.resolve();
      });
    }
  }, {
    key: "_add",
    value: function _add(transport) {
      if (!transport) {
        return;
      }
      (0, _util.assert)(!this._transport);
      this._transport = transport;
    }
  }]);
  return WorkerTask;
}();
exports.WorkerTask = WorkerTask;
var WorkerTransport = function () {
  function WorkerTransport(params, manager) {
    _classCallCheck(this, WorkerTransport);
    this._params = params;
    this._manager = manager;
    this._task = params.task;
    this._task._add(this);
    this._finished = false;
    this._capability = (0, _util.createPromiseCapability)();
  }
  _createClass(WorkerTransport, [{
    key: "finished",
    get: function get() {
      return this._capability.promise;
    }
  }, {
    key: "send",
    value: function send(msg, transfers) {
      if (this._finished) {
        return;
      }
      this._manager.send(msg, transfers);
    }
  }, {
    key: "cancel",
    value: function cancel() {
      this.finish();
    }
  }, {
    key: "finish",
    value: function finish() {
      var _this2 = this;
      if (this._finished) {
        return;
      }
      this._finished = true;
      this._task.finish();
      Promise.resolve().then(function () {
        _this2._capability.resolve();
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.cancel();
    }
  }]);
  return WorkerTransport;
}();
exports.WorkerTransport = WorkerTransport;
var WorkerMessageHandler = function (_MessageHandler) {
  _inherits(WorkerMessageHandler, _MessageHandler);
  var _super = _createSuper(WorkerMessageHandler);
  function WorkerMessageHandler(name, port) {
    var _this3;
    _classCallCheck(this, WorkerMessageHandler);
    _this3 = _super.call(this, name, port);
    _this3._readyCapability = (0, _util.createPromiseCapability)();
    _this3._tasks = new Map();
    _this3._streamTransports = new Map();
    return _this3;
  }
  _createClass(WorkerMessageHandler, [{
    key: "on",
    value: function on(action, handler) {
      this._port.on(action, handler);
    }
  }, {
    key: "send",
    value: function send(action, data, transfers) {
      this._port.send(action, data, transfers);
    }
  }, {
    key: "ready",
    get: function get() {
      return this._readyCapability.promise;
    }
  }, {
    key: "getDoc",
    value: function getDoc(data) {
      var _this4 = this;
      var pdfManager;
      var docId = data.docId;
      var task = new WorkerTask("getDoc_".concat(docId));
      this._tasks.set(docId, task);
      var source = data.source;
      if (source.data) {
        try {
          pdfManager = new _pdf_manager.PDFManager(this, source.data, source.password, source.docBaseUrl, source.isEvalSupported, source.disableRange, source.disableStream, source.ownerDocument, source.pdfBug);
        } catch (ex) {
          task.finish();
          var _ex = (0, _util.wrapException)(ex);
          this.send("docError", {
            docId: docId,
            error: _ex
          });
          return;
        }
      } else if (source.chunkedViewer) {
        try {
          pdfManager = new _pdf_manager.PDFManager(this, null, source.password, source.docBaseUrl, source.isEvalSupported, true, false, source.ownerDocument, source.pdfBug);
        } catch (ex) {
          task.finish();
          var _ex3 = (0, _util.wrapException)(ex);
          this.send("docError", {
            docId: docId,
            error: _ex3
          });
          return;
        }
        var stream = new _worker_stream.PDFWorkerStream(this, {
          docId: docId,
          length: source.length,
          disableRange: source.disableRange,
          disableStream: source.disableStream
        });
        pdfManager.load(stream);
      } else {
        task.finish();
        this.send("docError", {
          docId: docId,
          error: new _util.UnexpectedResponseException("Missing data.", "Missing data")
        });
        return;
      }
      pdfManager.getDoc().then(function (doc) {
        task.finish();
        _this4.send("docSuccess", {
          docId: docId,
          doc: doc
        });
      }, function (ex) {
        task.finish();
        var wrappedException = (0, _util.wrapException)(ex);
        _this4.send("docError", {
          docId: docId,
          error: wrappedException
        });
      });
    }
  }, {
    key: "cancel",
    value: function cancel(data) {
      var docId = data.docId;
      var task = this._tasks.get(docId);
      if (!task) {
        return;
      }
      task.cancel();
    }
  }, {
    key: "getPage",
    value: function getPage(data) {
      var _this5 = this;
      var docId = data.docId,
        pageNumber = data.pageNumber;
      var task = new WorkerTask("getPage_".concat(pageNumber, "@").concat(docId));
      this._tasks.set("".concat(docId, "_").concat(pageNumber), task);
      _pdf_manager.PDFManager.getPage(docId, pageNumber).then(function (page) {
        task.finish();
        _this5.send("pageSuccess", {
          docId: docId,
          pageNumber: pageNumber,
          page: page
        });
      }, function (ex) {
        task.finish();
        _this5.send("pageError", {
          docId: docId,
          pageNumber: pageNumber,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "renderPage",
    value: function renderPage(data) {
      var _this6 = this;
      var docId = data.docId,
        pageNumber = data.pageNumber,
        params = data.params;
      var task = new WorkerTask("renderPage_".concat(pageNumber, "@").concat(docId));
      this._tasks.set("render_".concat(docId, "_").concat(pageNumber), task);
      params.task = task;
      _pdf_manager.PDFManager.renderPage(docId, pageNumber, params).then(function () {
        task.finish();
        _this6.send("renderSuccess", {
          docId: docId,
          pageNumber: pageNumber
        });
      }, function (ex) {
        task.finish();
        _this6.send("renderError", {
          docId: docId,
          pageNumber: pageNumber,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getOperatorList",
    value: function getOperatorList(data) {
      var _this7 = this;
      var docId = data.docId,
        pageNumber = data.pageNumber;
      var task = new WorkerTask("getOperatorList_".concat(pageNumber, "@").concat(docId));
      this._tasks.set("oplist_".concat(docId, "_").concat(pageNumber), task);
      _pdf_manager.PDFManager.getOperatorList(docId, pageNumber, task).then(function (operatorList) {
        task.finish();
        _this7.send("oplistSuccess", {
          docId: docId,
          pageNumber: pageNumber,
          operatorList: operatorList
        }, [operatorList.fnArray.buffer, operatorList.argsArray.buffer]);
      }, function (ex) {
        task.finish();
        _this7.send("oplistError", {
          docId: docId,
          pageNumber: pageNumber,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getTextContent",
    value: function getTextContent(data) {
      var _this8 = this;
      var docId = data.docId,
        pageNumber = data.pageNumber;
      var task = new WorkerTask("getTextContent_".concat(pageNumber, "@").concat(docId));
      this._tasks.set("text_".concat(docId, "_").concat(pageNumber), task);
      _pdf_manager.PDFManager.getTextContent(docId, pageNumber, task).then(function (textContent) {
        task.finish();
        _this8.send("textSuccess", {
          docId: docId,
          pageNumber: pageNumber,
          textContent: textContent
        }, [textContent.bidiTexts.buffer]);
      }, function (ex) {
        task.finish();
        _this8.send("textError", {
          docId: docId,
          pageNumber: pageNumber,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getAnnotations",
    value: function getAnnotations(data) {
      var _this9 = this;
      var docId = data.docId,
        pageNumber = data.pageNumber;
      var task = new WorkerTask("getAnnotations_".concat(pageNumber, "@").concat(docId));
      this._tasks.set("annot_".concat(docId, "_").concat(pageNumber), task);
      _pdf_manager.PDFManager.getAnnotations(docId, pageNumber, task).then(function (annotations) {
        task.finish();
        _this9.send("annotSuccess", {
          docId: docId,
          pageNumber: pageNumber,
          annotations: annotations
        });
      }, function (ex) {
        task.finish();
        _this9.send("annotError", {
          docId: docId,
          pageNumber: pageNumber,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getXfa",
    value: function getXfa(data) {
      var _this10 = this;
      var docId = data.docId;
      var task = new WorkerTask("getXfa@".concat(docId));
      this._tasks.set("xfa_".concat(docId), task);
      _pdf_manager.PDFManager.getXfa(docId, task).then(function (xfa) {
        task.finish();
        _this10.send("xfaSuccess", {
          docId: docId,
          xfa: xfa
        });
      }, function (ex) {
        task.finish();
        _this10.send("xfaError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getStructTree",
    value: function getStructTree(data) {
      var _this11 = this;
      var docId = data.docId;
      var task = new WorkerTask("getStructTree@".concat(docId));
      this._tasks.set("structtree_".concat(docId), task);
      _pdf_manager.PDFManager.getStructTree(docId, task).then(function (structTree) {
        task.finish();
        _this11.send("structTreeSuccess", {
          docId: docId,
          structTree: structTree
        });
      }, function (ex) {
        task.finish();
        _this11.send("structTreeError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getAttachments",
    value: function getAttachments(data) {
      var _this12 = this;
      var docId = data.docId;
      var task = new WorkerTask("getAttachments@".concat(docId));
      this._tasks.set("attachments_".concat(docId), task);
      _pdf_manager.PDFManager.getAttachments(docId, task).then(function (attachments) {
        task.finish();
        _this12.send("attachmentsSuccess", {
          docId: docId,
          attachments: attachments
        });
      }, function (ex) {
        task.finish();
        _this12.send("attachmentsError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getJavaScript",
    value: function getJavaScript(data) {
      var _this13 = this;
      var docId = data.docId;
      var task = new WorkerTask("getJavaScript@".concat(docId));
      this._tasks.set("javascript_".concat(docId), task);
      _pdf_manager.PDFManager.getJavaScript(docId, task).then(function (javaScript) {
        task.finish();
        _this13.send("javaScriptSuccess", {
          docId: docId,
          javaScript: javaScript
        });
      }, function (ex) {
        task.finish();
        _this13.send("javaScriptError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getMetadata",
    value: function getMetadata(data) {
      var _this14 = this;
      var docId = data.docId;
      var task = new WorkerTask("getMetadata@".concat(docId));
      this._tasks.set("metadata_".concat(docId), task);
      _pdf_manager.PDFManager.getMetadata(docId, task).then(function (metadata) {
        task.finish();
        _this14.send("metadataSuccess", {
          docId: docId,
          metadata: metadata
        });
      }, function (ex) {
        task.finish();
        _this14.send("metadataError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getMarkedContent",
    value: function getMarkedContent(data) {
      var _this15 = this;
      var docId = data.docId,
        pageNumber = data.pageNumber;
      var task = new WorkerTask("getMarkedContent_".concat(pageNumber, "@").concat(docId));
      this._tasks.set("markedcontent_".concat(docId, "_").concat(pageNumber), task);
      _pdf_manager.PDFManager.getMarkedContent(docId, pageNumber, task).then(function (markedContent) {
        task.finish();
        _this15.send("markedContentSuccess", {
          docId: docId,
          pageNumber: pageNumber,
          markedContent: markedContent
        });
      }, function (ex) {
        task.finish();
        _this15.send("markedContentError", {
          docId: docId,
          pageNumber: pageNumber,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getDestinations",
    value: function getDestinations(data) {
      var _this16 = this;
      var docId = data.docId;
      var task = new WorkerTask("getDestinations@".concat(docId));
      this._tasks.set("destinations_".concat(docId), task);
      _pdf_manager.PDFManager.getDestinations(docId, task).then(function (destinations) {
        task.finish();
        _this16.send("destinationsSuccess", {
          docId: docId,
          destinations: destinations
        });
      }, function (ex) {
        task.finish();
        _this16.send("destinationsError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getPageIndex",
    value: function getPageIndex(data) {
      var _this17 = this;
      var docId = data.docId,
        ref = data.ref;
      var task = new WorkerTask("getPageIndex@".concat(docId));
      this._tasks.set("pageindex_".concat(docId), task);
      _pdf_manager.PDFManager.getPageIndex(docId, ref, task).then(function (pageIndex) {
        task.finish();
        _this17.send("pageIndexSuccess", {
          docId: docId,
          pageIndex: pageIndex
        });
      }, function (ex) {
        task.finish();
        _this17.send("pageIndexError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getOutline",
    value: function getOutline(data) {
      var _this18 = this;
      var docId = data.docId;
      var task = new WorkerTask("getOutline@".concat(docId));
      this._tasks.set("outline_".concat(docId), task);
      _pdf_manager.PDFManager.getOutline(docId, task).then(function (outline) {
        task.finish();
        _this18.send("outlineSuccess", {
          docId: docId,
          outline: outline
        });
      }, function (ex) {
        task.finish();
        _this18.send("outlineError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getPermissions",
    value: function getPermissions(data) {
      var _this19 = this;
      var docId = data.docId;
      var task = new WorkerTask("getPermissions@".concat(docId));
      this._tasks.set("permissions_".concat(docId), task);
      _pdf_manager.PDFManager.getPermissions(docId, task).then(function (permissions) {
        task.finish();
        _this19.send("permissionsSuccess", {
          docId: docId,
          permissions: permissions
        });
      }, function (ex) {
        task.finish();
        _this19.send("permissionsError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getOptionalContentConfig",
    value: function getOptionalContentConfig(data) {
      var _this20 = this;
      var docId = data.docId;
      var task = new WorkerTask("getOptionalContentConfig@".concat(docId));
      this._tasks.set("optionalcontentconfig_".concat(docId), task);
      _pdf_manager.PDFManager.getOptionalContentConfig(docId, task).then(function (optionalContentConfig) {
        task.finish();
        _this20.send("optionalContentConfigSuccess", {
          docId: docId,
          optionalContentConfig: optionalContentConfig
        });
      }, function (ex) {
        task.finish();
        _this20.send("optionalContentConfigError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getJSActions",
    value: function getJSActions(data) {
      var _this21 = this;
      var docId = data.docId;
      var task = new WorkerTask("getJSActions@".concat(docId));
      this._tasks.set("jsactions_".concat(docId), task);
      _pdf_manager.PDFManager.getJSActions(docId, task).then(function (jsActions) {
        task.finish();
        _this21.send("jsActionsSuccess", {
          docId: docId,
          jsActions: jsActions
        });
      }, function (ex) {
        task.finish();
        _this21.send("jsActionsError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getCalculationOrderIds",
    value: function getCalculationOrderIds(data) {
      var _this22 = this;
      var docId = data.docId;
      var task = new WorkerTask("getCalculationOrderIds@".concat(docId));
      this._tasks.set("calculationorderids_".concat(docId), task);
      _pdf_manager.PDFManager.getCalculationOrderIds(docId, task).then(function (calculationOrderIds) {
        task.finish();
        _this22.send("calculationOrderIdsSuccess", {
          docId: docId,
          calculationOrderIds: calculationOrderIds
        });
      }, function (ex) {
        task.finish();
        _this22.send("calculationOrderIdsError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getFieldObjects",
    value: function getFieldObjects(data) {
      var _this23 = this;
      var docId = data.docId;
      var task = new WorkerTask("getFieldObjects@".concat(docId));
      this._tasks.set("fieldobjects_".concat(docId), task);
      _pdf_manager.PDFManager.getFieldObjects(docId, task).then(function (fieldObjects) {
        task.finish();
        _this23.send("fieldObjectsSuccess", {
          docId: docId,
          fieldObjects: fieldObjects
        });
      }, function (ex) {
        task.finish();
        _this23.send("fieldObjectsError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "hasJSActions",
    value: function hasJSActions(data) {
      var _this24 = this;
      var docId = data.docId;
      var task = new WorkerTask("hasJSActions@".concat(docId));
      this._tasks.set("hasjsactions_".concat(docId), task);
      _pdf_manager.PDFManager.hasJSActions(docId, task).then(function (hasJSActions) {
        task.finish();
        _this24.send("hasJSActionsSuccess", {
          docId: docId,
          hasJSActions: hasJSActions
        });
      }, function (ex) {
        task.finish();
        _this24.send("hasJSActionsError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getAcroForm",
    value: function getAcroForm(data) {
      var _this25 = this;
      var docId = data.docId;
      var task = new WorkerTask("getAcroForm@".concat(docId));
      this._tasks.set("acroform_".concat(docId), task);
      _pdf_manager.PDFManager.getAcroForm(docId, task).then(function (acroForm) {
        task.finish();
        _this25.send("acroFormSuccess", {
          docId: docId,
          acroForm: acroForm
        });
      }, function (ex) {
        task.finish();
        _this25.send("acroFormError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getFingerprint",
    value: function getFingerprint(data) {
      var _this26 = this;
      var docId = data.docId;
      var task = new WorkerTask("getFingerprint@".concat(docId));
      this._tasks.set("fingerprint_".concat(docId), task);
      _pdf_manager.PDFManager.getFingerprint(docId, task).then(function (fingerprint) {
        task.finish();
        _this26.send("fingerprintSuccess", {
          docId: docId,
          fingerprint: fingerprint
        });
      }, function (ex) {
        task.finish();
        _this26.send("fingerprintError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "saveDocument",
    value: function saveDocument(data) {
      var _this27 = this;
      var docId = data.docId;
      var task = new WorkerTask("saveDocument@".concat(docId));
      this._tasks.set("savedocument_".concat(docId), task);
      _pdf_manager.PDFManager.saveDocument(docId, task).then(function (saved) {
        task.finish();
        _this27.send("saveDocumentSuccess", {
          docId: docId,
          saved: saved
        });
      }, function (ex) {
        task.finish();
        _this27.send("saveDocumentError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getDownloadInfo",
    value: function getDownloadInfo(data) {
      var _this28 = this;
      var docId = data.docId;
      var task = new WorkerTask("getDownloadInfo@".concat(docId));
      this._tasks.set("downloadinfo_".concat(docId), task);
      _pdf_manager.PDFManager.getDownloadInfo(docId, task).then(function (downloadInfo) {
        task.finish();
        _this28.send("downloadInfoSuccess", {
          docId: docId,
          downloadInfo: downloadInfo
        });
      }, function (ex) {
        task.finish();
        _this28.send("downloadInfoError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getViewerPreferences",
    value: function getViewerPreferences(data) {
      var _this29 = this;
      var docId = data.docId;
      var task = new WorkerTask("getViewerPreferences@".concat(docId));
      this._tasks.set("viewerpreferences_".concat(docId), task);
      _pdf_manager.PDFManager.getViewerPreferences(docId, task).then(function (viewerPreferences) {
        task.finish();
        _this29.send("viewerPreferencesSuccess", {
          docId: docId,
          viewerPreferences: viewerPreferences
        });
      }, function (ex) {
        task.finish();
        _this29.send("viewerPreferencesError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "getOpenAction",
    value: function getOpenAction(data) {
      var _this30 = this;
      var docId = data.docId;
      var task = new WorkerTask("getOpenAction@".concat(docId));
      this._tasks.set("openaction_".concat(docId), task);
      _pdf_manager.PDFManager.getOpenAction(docId, task).then(function (openAction) {
        task.finish();
        _this30.send("openActionSuccess", {
          docId: docId,
          openAction: openAction
        });
      }, function (ex) {
        task.finish();
        _this30.send("openActionError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "cleanup",
    value: function cleanup(data) {
      var docId = data.docId;
      _pdf_manager.PDFManager.cleanup(docId);
      var _iterator = _createForOfIteratorHelper(this._tasks.keys()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var key = _step.value;
          if (key.endsWith(docId)) {
            this._tasks["delete"](key);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "init",
    value: function init(data) {
      var _this31 = this;
      var workerVersion = "5.3.93";
      var pdfJsVersion = data.pdfJsVersion;
      if (pdfJsVersion !== workerVersion) {
        throw new Error("The API version \"".concat(pdfJsVersion, "\" does not match the Worker version \"").concat(workerVersion, "\"."));
      }
      var fonts = [];
      var _iterator2 = _createForOfIteratorHelper(data.fontPaths),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _step2.value,
            name = _step2$value.name,
            path = _step2$value.path;
          fonts.push((0, _fonts.fetchStandardFontData)(name, path));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      Promise.all(fonts).then(function (standardFontData) {
        _fonts.StandardFonts.setData(standardFontData);
        _this31._readyCapability.resolve();
      })["catch"](function (reason) {
        _this31._readyCapability.reject(reason);
      });
    }
  }, {
    key: "fontFallback",
    value: function fontFallback(data) {
      var _this32 = this;
      var docId = data.docId,
        id = data.id,
        name = data.name;
      _pdf_manager.PDFManager.fontFallback(docId, id, name).then(function (args) {
        _this32.send("fontFallbackSuccess", {
          docId: docId,
          args: args
        });
      })["catch"](function (ex) {
        _this32.send("fontFallbackError", {
          docId: docId,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "streamRange",
    value: function streamRange(data) {
      var _this33 = this;
      var docId = data.docId,
        begin = data.begin,
        end = data.end;
      var task = new WorkerTask("streamRange_".concat(begin, "_").concat(end, "@").concat(docId));
      this._tasks.set("streamrange_".concat(docId, "_").concat(begin), task);
      _pdf_manager.PDFManager.streamRange(docId, begin, end, task).then(function (result) {
        task.finish();
        _this33.send("streamRangeSuccess", {
          docId: docId,
          begin: begin,
          result: result
        });
      }, function (ex) {
        task.finish();
        _this33.send("streamRangeError", {
          docId: docId,
          begin: begin,
          error: (0, _util.wrapException)(ex)
        });
      });
    }
  }, {
    key: "streamFromArray",
    value: function streamFromArray(data) {
      var docId = data.docId,
        array = data.array;
      _pdf_manager.PDFManager.streamFromArray(docId, array);
    }
  }, {
    key: "streamFromFile",
    value: function streamFromFile(data) {
      var docId = data.docId,
        file = data.file;
      _pdf_manager.PDFManager.streamFromFile(docId, file);
    }
  }, {
    key: "streamFromUrl",
    value: function streamFromUrl(data) {
      var docId = data.docId,
        url = data.url;
      _pdf_manager.PDFManager.streamFromUrl(docId, url);
    }
  }, {
    key: "streamFromData",
    value: function streamFromData(data) {
      var docId = data.docId,
        chunk = data.chunk;
      _pdf_manager.PDFManager.streamFromData(docId, chunk);
    }
  }, {
    key: "streamEnd",
    value: function streamEnd(data) {
      var docId = data.docId;
      _pdf_manager.PDFManager.streamEnd(docId);
    }
  }, {
    key: "streamAbort",
    value: function streamAbort(data) {
      var docId = data.docId;
      _pdf_manager.PDFManager.streamAbort(docId);
    }
  }, {
    key: "quit",
    value: function quit() {
      this._port.close();
    }
  }]);
  return WorkerMessageHandler;
}(_message_handler.MessageHandler);
exports.WorkerMessageHandler = WorkerMessageHandler;

/***/ }),

/***/ 817:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _typeof = __webpack_require__(46);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageHandler = void 0;
var _util = __webpack_require__(80);
var _is_node = __webpack_require__(345);
var MessageHandler = function () {
  function MessageHandler(name, port) {
    _classCallCheck(this, MessageHandler);
    this._name = name;
    this._port = port;
    this._port.on("message", this._onMessage.bind(this));
  }
  _createClass(MessageHandler, [{
    key: "_onMessage",
    value: function _onMessage(evt) {
      var action = evt.data.action;
      var handlerName = (0, _util.camelCase)(action);
      if (typeof this[handlerName] !== "function") {
        (0, _util.warn)("".concat(this._name, ": Unsupported action \"").concat(action, "\""));
        return;
      }
      this[handlerName](evt.data.data);
    }
  }]);
  return MessageHandler;
}();
exports.MessageHandler = MessageHandler;

/***/ }),

/***/ 375:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _regenerator = _interopRequireDefault(__webpack_require__(936));
var _typeof = __webpack_require__(46);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFManager = void 0;
var _util = __webpack_require__(80);
var _primitives = __webpack_require__(240);
var _parser = __webpack_require__(15);
var _cmap = __webpack_require__(37);
var _stream = __webpack_require__(246);
var _core_utils = __webpack_require__(397);
var _crypto = __webpack_require__(878);
var _document = __webpack_require__(120);
var _is_node = __webpack_require__(345);
var _network = __webpack_require__(395);
var _worker_stream = __webpack_require__(277);
var pdfManagerInstances = new Map();
var PDFManager = function () {
  function PDFManager(owner, data, password, docBaseUrl, isEvalSupported, disableRange, disableStream, ownerDocument, pdfBug) {
    _classCallCheck(this, PDFManager);
    this._owner = owner;
    this._docId = (0, _util.createValidAbsoluteUrl)(docBaseUrl, null).href;
    this._password = password;
    this._docBaseUrl = docBaseUrl;
    this._isEvalSupported = isEvalSupported;
    this._disableRange = disableRange;
    this._disableStream = disableStream;
    this._ownerDocument = ownerDocument;
    this._pdfBug = pdfBug;
    this._doc = null;
    this._pdfDocument = null;
    this._transport = null;
    this._capability = (0, _util.createPromiseCapability)();
    this._loadedStream = null;
    pdfManagerInstances.set(this._docId, this);
    if (data) {
      this.load(data);
    }
  }
  _createClass(PDFManager, [{
    key: "getDoc",
    value: function getDoc() {
      return this._capability.promise;
    }
  }, {
    key: "load",
    value: function load(data) {
      var _this = this;
      var stream;
      if (data instanceof _worker_stream.PDFWorkerStream) {
        stream = data;
      } else if ((0, _util.isTypedArray)(data)) {
        stream = new _stream.Stream(data);
      } else {
        (0, _util.unreachable)("Invalid data type");
      }
      this._loadedStream = stream;
      var _this$_owner$_params = this._owner._params,
        docId = _this$_owner$_params.docId,
        task = _this$_owner$_params.task;
      var transportParams = {
        docId: docId,
        password: this._password,
        isEvalSupported: this._isEvalSupported,
        ownerDocument: this._ownerDocument,
        pdfBug: this._pdfBug,
        task: task
      };
      this._transport = new _network.PDFNetworkStream(stream, {
        docBaseUrl: this._docBaseUrl,
        disableRange: this._disableRange,
        disableStream: this._disableStream
      });
      this._transport.getFullReader().then(function (stream) {
        var doc = new _document.PDFDocument(_this, stream);
        _this._doc = doc;
        doc.parse().then(function () {
          _this._capability.resolve(doc.getIR());
        })["catch"](function (ex) {
          _this._capability.reject(ex);
        });
      })["catch"](function (ex) {
        _this._capability.reject(ex);
      });
    }
  }, {
    key: "streamRange",
    value: function streamRange(begin, end) {
      return this._loadedStream.getRange(begin, end);
    }
  }, {
    key: "streamFromArray",
    value: function streamFromArray(array) {
      this._loadedStream.append(array);
    }
  }, {
    key: "streamFromData",
    value: function streamFromData(chunk) {
      this._loadedStream.append(chunk);
    }
  }, {
    key: "streamEnd",
    value: function streamEnd() {
      this._loadedStream.end();
    }
  }, {
    key: "streamAbort",
    value: function streamAbort() {
      this._loadedStream.cancel();
    }
  }], [{
    key: "create",
    value: function create(owner, data, password, docBaseUrl, isEvalSupported, disableRange, disableStream, ownerDocument, pdfBug) {
      return new PDFManager(owner, data, password, docBaseUrl, isEvalSupported, disableRange, disableStream, ownerDocument, pdfBug);
    }
  }, {
    key: "get",
    value: function get(docId) {
      return pdfManagerInstances.get(docId);
    }
  }, {
    key: "cleanup",
    value: function cleanup(docId) {
      var instance = pdfManagerInstances.get(docId);
      if (!instance) {
        return;
      }
      instance._doc.cleanup();
      pdfManagerInstances["delete"](docId);
    }
  }, {
    key: "getPage",
    value: function getPage(docId, pageNumber) {
      return pdfManagerInstances.get(docId)._doc.getPage(pageNumber);
    }
  }, {
    key: "renderPage",
    value: function renderPage(docId, pageNumber, params) {
      return pdfManagerInstances.get(docId)._doc.renderPage(pageNumber, params);
    }
  }, {
    key: "getOperatorList",
    value: function getOperatorList(docId, pageNumber, task) {
      return pdfManagerInstances.get(docId)._doc.getOperatorList(pageNumber, task);
    }
  }, {
    key: "getTextContent",
    value: function getTextContent(docId, pageNumber, task) {
      return pdfManagerInstances.get(docId)._doc.getTextContent(pageNumber, task);
    }
  }, {
    key: "getAnnotations",
    value: function getAnnotations(docId, pageNumber, task) {
      return pdfManagerInstances.get(docId)._doc.getAnnotations(pageNumber, task);
    }
  }, {
    key: "getXfa",
    value: function getXfa(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getXfa(task);
    }
  }, {
    key: "getStructTree",
    value: function getStructTree(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getStructTree(task);
    }
  }, {
    key: "getAttachments",
    value: function getAttachments(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getAttachments(task);
    }
  }, {
    key: "getJavaScript",
    value: function getJavaScript(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getJavaScript(task);
    }
  }, {
    key: "getMetadata",
    value: function getMetadata(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getMetadata(task);
    }
  }, {
    key: "getMarkedContent",
    value: function getMarkedContent(docId, pageNumber, task) {
      return pdfManagerInstances.get(docId)._doc.getMarkedContent(pageNumber, task);
    }
  }, {
    key: "getDestinations",
    value: function getDestinations(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getDestinations(task);
    }
  }, {
    key: "getPageIndex",
    value: function getPageIndex(docId, ref, task) {
      return pdfManagerInstances.get(docId)._doc.getPageIndex(ref, task);
    }
  }, {
    key: "getOutline",
    value: function getOutline(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getOutline(task);
    }
  }, {
    key: "getPermissions",
    value: function getPermissions(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getPermissions(task);
    }
  }, {
    key: "getOptionalContentConfig",
    value: function getOptionalContentConfig(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getOptionalContentConfig(task);
    }
  }, {
    key: "getJSActions",
    value: function getJSActions(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getJSActions(task);
    }
  }, {
    key: "getCalculationOrderIds",
    value: function getCalculationOrderIds(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getCalculationOrderIds(task);
    }
  }, {
    key: "getFieldObjects",
    value: function getFieldObjects(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getFieldObjects(task);
    }
  }, {
    key: "hasJSActions",
    value: function hasJSActions(docId, task) {
      return pdfManagerInstances.get(docId)._doc.hasJSActions(task);
    }
  }, {
    key: "getAcroForm",
    value: function getAcroForm(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getAcroForm(task);
    }
  }, {
    key: "getFingerprint",
    value: function getFingerprint(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getFingerprint(task);
    }
  }, {
    key: "saveDocument",
    value: function saveDocument(docId, task) {
      return pdfManagerInstances.get(docId)._doc.saveDocument(task);
    }
  }, {
    key: "getDownloadInfo",
    value: function getDownloadInfo(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getDownloadInfo(task);
    }
  }, {
    key: "getViewerPreferences",
    value: function getViewerPreferences(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getViewerPreferences(task);
    }
  }, {
    key: "getOpenAction",
    value: function getOpenAction(docId, task) {
      return pdfManagerInstances.get(docId)._doc.getOpenAction(task);
    }
  }, {
    key: "fontFallback",
    value: function fontFallback(docId, id, name) {
      return pdfManagerInstances.get(docId)._doc.fontFallback(id, name);
    }
  }, {
    key: "streamRange",
    value: function streamRange(docId, begin, end, task) {
      return pdfManagerInstances.get(docId).streamRange(begin, end, task);
    }
  }, {
    key: "streamFromArray",
    value: function streamFromArray(docId, array) {
      pdfManagerInstances.get(docId).streamFromArray(array);
    }
  }, {
    key: "streamFromData",
    value: function streamFromData(docId, chunk) {
      pdfManagerInstances.get(docId).streamFromData(chunk);
    }
  }, {
    key: "streamEnd",
    value: function streamEnd(docId) {
      pdfManagerInstances.get(docId).streamEnd();
    }
  }, {
    key: "streamAbort",
    value: function streamAbort(docId) {
      pdfManagerInstances.get(docId).streamAbort();
    }
  }]);
  return PDFManager;
}();
exports.PDFManager = PDFManager;

/***/ }),

/***/ 277:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _typeof = __webpack_require__(46);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFWorkerStream = void 0;
var _base_stream = __webpack_require__(34);
var _util = __webpack_require__(80);
var _is_node = __webpack_require__(345);
var PDFWorkerStream = function () {
  function PDFWorkerStream(msgHandler, params) {
    _classCallCheck(this, PDFWorkerStream);
    this._msgHandler = msgHandler;
    this._params = params;
    this._requests = new Map();
    this._reader = null;
    this._msgHandler.on("streamRange", this._onReceiveData.bind(this));
    this._msgHandler.on("streamRangeError", this._onReceiveError.bind(this));
  }
  _createClass(PDFWorkerStream, [{
    key: "getReader",
    value: function getReader() {
      if (!this._reader) {
        this._reader = new _base_stream.PDFDataRangeTransport(this._params.length, this);
      }
      return this._reader;
    }
  }, {
    key: "requestDataRange",
    value: function requestDataRange(begin, end) {
      var capability = (0, _util.createPromiseCapability)();
      this._requests.set(begin, capability);
      this._msgHandler.send("streamRange", {
        docId: this._params.docId,
        begin: begin,
        end: end
      });
    }
  }, {
    key: "_onReceiveData",
    value: function _onReceiveData(data) {
      var begin = data.begin,
        chunk = data.chunk;
      var capability = this._requests.get(begin);
      if (!capability) {
        return;
      }
      this._requests["delete"](begin);
      capability.resolve(chunk);
    }
  }, {
    key: "_onReceiveError",
    value: function _onReceiveError(data) {
      var begin = data.begin,
        error = data.error;
      var capability = this._requests.get(begin);
      if (!capability) {
        return;
      }
      this._requests["delete"](begin);
      capability.reject(error);
    }
  }]);
  return PDFWorkerStream;
}();
exports.PDFWorkerStream = PDFWorkerStream;

/***/ }),

/***/ 46:
/***/ ((module) => {

"use strict";


function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 936:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _typeof = __webpack_require__(46);
function _typeof2(obj) { "@babel/helpers - typeof"; return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof2(obj); }
var _regeneratorRuntime = require("regenerator-runtime");
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
try {
  regeneratorRuntime = _regeneratorRuntime;
} catch (e) {
  "object" === ("undefined" == typeof globalThis ? "undefined" : _typeof2(globalThis)) ? globalThis.regeneratorRuntime = _regeneratorRuntime : "object" === ("undefined" == typeof self ? "undefined" : _typeof2(self)) ? self.regeneratorRuntime = _regeneratorRuntime : "object" === ("undefined" == typeof window ? "undefined" : _typeof2(window)) ? window.regeneratorRuntime = _regeneratorRuntime : "function" == typeof eval && eval("regeneratorRuntime = _regeneratorRuntime");
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
"use strict";


var _worker = __webpack_require__(649);
var _is_node = __webpack_require__(345);
var _message_handler = __webpack_require__(817);
var _util = __webpack_require__(80);
var _version = __webpack_require__(890);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var pdfjsWorker = typeof window !== "undefined" && window["pdfjs-dist/build/pdf.worker"] ? window["pdfjs-dist/build/pdf.worker"] : null;
if (typeof pdfjsWorker === "undefined") {
  var workerSrc;
  if (typeof process !== "undefined" && process.env.PDF_WORKER_SRC) {
    workerSrc = process.env.PDF_WORKER_SRC;
  } else if (typeof PDF_WORKER_SRC !== "undefined") {
    workerSrc = PDF_WORKER_SRC;
  }
  if (workerSrc) {
    try {
      importScripts(workerSrc);
    } catch (e) {
      console.error(e);
    }
  } else if (_is_node.isNodeJS) {
    var path = require("path");
    var fs = require("fs");
    var workerData = fs.readFileSync(path.join(__dirname, "pdf.worker.js"), "utf8");
    (0, eval)(workerData);
  } else {
    throw new Error('Could not load "pdf.worker.js".');
  }
}
var WORKER_FUNCTIONS = ["on", "send"];
var WorkerProxy = function WorkerProxyClosure() {
  function WorkerProxy(port) {
    this._port = port;
    var _iterator = _createForOfIteratorHelper(WORKER_FUNCTIONS),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var funName = _step.value;
        this[funName] = function (action, data, transfers) {
          this._port.postMessage({
            action: action,
            data: data
          }, transfers);
        }.bind(this);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return WorkerProxy;
}();
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var handler = new _worker.WorkerMessageHandler(_version.EXPORT_NAME, new WorkerProxy(self));
self.onmessage = function (evt) {
  var action = evt.data.action;
  if (action === "configure") {
    var port = evt.ports[0];
    handler = new _worker.WorkerMessageHandler(_version.EXPORT_NAME, new WorkerProxy(port));
  } else {
    handler._onMessage(evt);
  }
};
})();

/******/ })()
;
